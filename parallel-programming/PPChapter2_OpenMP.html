<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>OpenMP (Open Multi-Processing) :: Parallel Programming</title>
    <link rel="canonical" href="https://feelpp.github.io/parallel-programming/parallel-programming/PPChapter2_OpenMP.html">
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../_/css/site.css">
<link rel="icon" href="../_/img/favicon.ico" type="image/x-icon">
<script>!function(l,p){if(l.protocol!==p&&l.host=="docs.antora.org"){l.protocol=p}else if(/\.gitlab\.io$/.test(l.host)){l.replace(p+"//docs.antora.org"+l.pathname.substr(l.pathname.indexOf("/",1))+l.search+l.hash)}}(location,"https:")</script>

<script src="../_/js/vendor/tabs-block-extension.js"></script>
<script src="../_/js/vendor/tabs-block-behavior.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\\[','\\]']],
    processEscapes: true,
    processEnvironments: true,
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },

  TeX: {
      Macros: {
      bold: ["{\\bf #1}",1],
      calTh: "{\\mathcal{T}_h}",
      card: ["{\\operatorname{card}(#1)}",1],
      card: ["{\\operatorname{card}(#1)}",1],
      Ck: ["{\\mathcal{C}^{#1}}",1],
      deformt: ["{\\mathbf{\\varepsilon(#1)}}",1],
      diam: "{\\operatorname{diam}}",
      dim: ["{\\operatorname{dim}(#1)}",1],
      disp: ["{\\mathbf{#1}}",1],
      domain: "{\\Omega}",
      ds: "",
      essinf: "{\\operatorname{ess}\\, \\operatorname{inf}}",
      F:"{\\mathcal{F}}",
      geo: "{\\mathrm{geo}}",
      Ich: ["{\\mathcal{I}^{#1}_{c,h}#2}",2],
      Id: "{\\mathcal{I}}",
      Ilag: ["{\\mathcal{I}^{\\mathrm{lag}}_{#1}}",1],
      jump: ["{[\\![ #1 ]\\!]}",1],
      n:"{\\mathbf{n}}",
      Ne: "{N_{\\mathrm{e}}}",
      Next: "{\\mathrm{n}}",
      nf: "{n_f}",
      ngeo: "{n_{\\mathrm{geo}}}",
      Nma: "{N_{\\mathrm{ma}}}",
      NN: "{\\mathbb N}",
      Nno: "{N_{\\mathrm{no}}}",
      Nso: "{N_{\\mathrm{so}}}",
      opdim: "{\\operatorname{dim}}",
      p: "{\\mathrm{p}}",
      P:"{\\mathcal{P}}",
      Pch: ["{P^{#1}_{c,h}}",1],
      Pcho: ["{P^{#1}_{c,h,0}}",1],
      Pk: ["{\\mathcal{P}^{#1}}",1],
      poly: ["{\\mathbb{#1}",1],
      poly: ["{\\mathbb{#1}}",1],
      prect: ["{\\left\\(#1\\right\\)}",1],
      q:"{\\mathbf{q}}",
      Qch: ["{Q^{#1}_{c,h}}",1],
      Qk: ["{\\mathcal{Q}^{#1}}",1],
      R: ["{\\mathbb{R}^{#1}}",1],
      RR: "{\\mathbb R}",
      set: ["{\\left\\{#1\\right\\}}",1],
      stresst: ["{\\mathbf{\\sigma(#1)}}",1],
      T:"{\\mathcal{T}}",
      tr: "{\\operatorname{tr}}",
      v:"{\\mathbf{v}}",
      vertiii: ["\\left\\vert\\kern-0.25ex\\left\\vert\\kern-0.25ex\\left\\vert #1 \\right\\vert\\kern-0.25ex\\right\\vert\\kern-0.25ex\\right\\vert",1]
  },
  extensions: ["mhchem.js"] 
  }
});
</script>
<!--<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>-->
<!-- <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML' async></script> -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_CHTML'></script>
<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.0/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>-->

<!--<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css" integrity="sha384-TEMocfGvRuD1rIAacqrknm5BQZ7W7uWitoih+jMNFXQIbNl16bO8OZmylH/Vi/Ei" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.js" integrity="sha384-jmxIlussZWB7qCuB+PgKG1uLjjxbVVIayPJwi6cG6Zb4YKq0JIw+OMnkkEC7kYCq" crossorigin="anonymous"></script>-->
<script>var uiRootPath = '../_'</script>

  </head>
  <body class="article">
<header class="header">
    <nav class="navbar navbar-expand-sm bg-dark navbar-dark navbar-template-project" style="border-top: 4px solid #9E9E9E">
        <div class="navbar-brand">
            <div class="navbar-item feelpp-logo">
                <a href="https://feelpp.github.io/parallel-programming">Parallel Programming</a>
            </div>
            <button class="navbar-burger" data-target="topbar-nav">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>

        <div id="topbar-nav" class="navbar-menu">
            <div class="navbar-end">
                <div class="navbar-item">
                    <a href="https://docs.feelpp.org/">Documentation Reference</a>
                </div>
                <div class="navbar-item has-dropdown is-hoverable download-item">
                    <div class="navbar-item"><a href="https://docs.feelpp.org/user/latest/install/index.html" class="download-btn">Get Feel++</a></div>
                </div>
                <div class="navbar-item">
                    <a class="navbar-brand"  href="https://www.cemosis.fr">
                        <img class="cemosis-logo"  src="../_/img/cemosis-logo.svg" alt="Cemosis logo"/>
                    </a>
                </div>
            </div>
        </div>
    </nav>
</header>
<div class="body">
<a href="#" class="menu-expand-toggle"></a>
<div class="nav-container" data-component="parallel-programming" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html">Main</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="PPChapter1_CPU.html">CPU Architecture</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="PPChapter1_GPU.html">GPU Architecture</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="PPChapter1_GPGPU.html">GPGPU Architecture</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="PPChapter1_TPU.html">TPU Architecture</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="PPChapter1_SIMD.html">SIMD Architecture</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="PPChapter2_MPI.html">MPI (Message Passing Interface)</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="PPChapter2_OpenMP.html">OpenMP (Open Multi-Processing)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="PPChapter2_OpenMP2.html">OpenMP more information</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="PPChapter2_Hybrid.html">Hybrid MPI with OpenMP</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="PPChapter3.html">StarPU</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="PPChapter4.html">Specx</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Main</span>
    <span class="version"></span>
  </div>
  <ul class="components">
      <li class="component">
        <a class="title" href="../feelpp-antora-ui/index.html">Antora Feel++ UI</a>
      </li>
      <li class="component is-current">
        <a class="title" href="index.html">Main</a>
      </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
  <button class="nav-toggle"></button>
    <a href="index.html" class="home-link"></a>
  <nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Main</a></li>
    <li><a href="PPChapter2_OpenMP.html">OpenMP (Open Multi-Processing)</a></li>
  </ul>
</nav>

  
    <div class="edit-this-page"><a href="https://github.com/feelpp/parallel-programming/edit/lem/docs/modules/ROOT/pages/PPChapter2_OpenMP.adoc">Edit this Page</a></div>
  
  <div class="page-downloads">
  <span class="label">Download as</span>
  <ul class="download-options">
    <li>
      <a onclick="print(this)" href="#" data-toggle="tooltip" data-placement="left" title="Print to PDF"
         class="pdf-download">
        <img class="pdf-file-icon icon" src="../_/img/pdf.svg"/> .pdf
      </a>
    </li>
  </ul>
</div>
</div>

  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">OpenMP (Open Multi-Processing)</h1>
<div class="sect1">
<h2 id="_definition"><a class="anchor" href="#_definition"></a>1. Definition</h2>
<div class="sectionbody">
<div class="paragraph">
<p>OpenMP ( Open Multi-Processing ) is a programming interface for parallel
computing on shared memory architecture.</p>
</div>
<div class="paragraph">
<p>It allows you to manage:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the creation of light processes,</p>
</li>
<li>
<p>the sharing of work between these lightweight processes,</p>
</li>
<li>
<p>synchronizations (explicit or implicit) between all light processes,</p>
</li>
<li>
<p>the status of the variables (private or shared).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_general_concepts"><a class="anchor" href="#_general_concepts"></a>2. General concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An OpenMP program is executed by a single process.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This process activates lightweight processes (threads) at the entrance
to a parallel region.<br></p>
</li>
<li>
<p>Each thread performs a task consisting of a set of instructions.<br></p>
</li>
<li>
<p>During the execution of a task, a variable can be read and/or modified
in memory.</p>
<div class="ulist">
<ul>
<li>
<p>It can be defined in the stack (local memory space) of a lightweight process; we then speak of a private variable</p>
</li>
<li>
<p>It can be defined in a shared memory space</p>
</li>
</ul>
</div>
</li>
<li>
<p>An OpenMP program is an alternation of sequential regions and parallel
regions.<br></p>
</li>
<li>
<p>A sequential region is always executed by the master task, the one
whose rank is 0.<br></p>
</li>
<li>
<p>A parallel region can be executed by several tasks at the same time.<br></p>
</li>
<li>
<p>The tasks can share the work contained in the parallel region.</p>
</li>
<li>
<p>Work sharing essentially consists of:</p>
<div class="ulist">
<ul>
<li>
<p>execute a loop by distributing the iterations between the tasks;<br></p>
</li>
<li>
<p>execute several sections of code but only one per task;<br></p>
</li>
<li>
<p>execute several occurrences of the same procedure by different tasks (orphaning)</p>
</li>
</ul>
</div>
</li>
<li>
<p>It is sometimes necessary to introduce a synchronization between the
concurrent tasks to avoid, for example, that these modify in any order
the value of the same shared variable (case of reduction operations).</p>
</li>
<li>
<p>Generally, tasks are assigned to processors by the operating system.
Different cases can occur:</p>
<div class="ulist">
<ul>
<li>
<p>at best, at each instant, there is one task per processor with as many
tasks as there are dedicated processors for the duration of the work;<br></p>
</li>
<li>
<p>at worst, all tasks are processed sequentially by one and only one
processor;<br></p>
</li>
<li>
<p>in reality, for reasons essentially of operation on a machine whose
processors are not dedicated, the situation is generally intermediate.</p>
</li>
</ul>
</div>
</li>
<li>
<p>To overcome these problems, it is possible to build the OpenMP runtime
on a library of mixed threads and thus control the scheduling of tasks.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_construction_of_a_parallel_region"><a class="anchor" href="#_construction_of_a_parallel_region"></a>3. Construction of a parallel region</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>In a parallel region, by default, the status of variables is shared.</p>
</li>
<li>
<p>Within a single parallel region, all concurrent tasks execute the same
code.</p>
</li>
<li>
<p>There is an implicit synchronization barrier at the end of the
parallel region.</p>
</li>
<li>
<p>“Branching” (eg GOTO, CYCLE, etc.) into or out of a parallel region or
any other OpenMP construct is prohibited.</p>
</li>
<li>
<p>It is possible, thanks to the DEFAULT clause, to change the default
status of variables in a parallel region.</p>
</li>
<li>
<p>If a variable has a private status (PRIVATE), it is in the stack of
each task. Its value is then undefined at the entry of a parallel region
(in the example opposite, the variable a equals 0 at the entry of the
parallel region)</p>
</li>
<li>
<p>However, thanks to the FIRSTPRIVATE clause, it is possible to force
the initialization of this private variable to the last value it had
before entering the parallel region.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extent_of_a_parallel_region"><a class="anchor" href="#_extent_of_a_parallel_region"></a>4. Extent of a parallel region</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>The scope of an OpenMP construct represents the scope of its influence
in the program.<br>
The influence (or scope) of a parallel region extends both to the code
contained lexically in this region (static scope), and to the code of
the called subroutines. The union of the two represents “dynamic
extent”.</p>
</li>
<li>
<p>In a subroutine called in a parallel region, the local and automatic
variables are implicitly private to each of the tasks (they are defined
in the stack of each task).</p>
</li>
<li>
<p>In a procedure, all the variables passed by argument (dummy
parameters) by reference, inherit the status defined in the lexical
scope (static) of the region.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_case_of_static_variables"><a class="anchor" href="#_case_of_static_variables"></a>5. Case of static variables</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>A variable is static if its location in memory is defined at
declaration by the compiler</p>
</li>
<li>
<p>Using the THREADPRIVATE directive allows you to privatize a static
instance and make it persistent from one parallel region to another. (
omp_get_thread_num(); )</p>
</li>
<li>
<p>If, in addition, the COPYIN clause is specified then the value of
static instances is passed to all tasks.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_case_of_dynamic_allocation"><a class="anchor" href="#_case_of_dynamic_allocation"></a>6. Case of dynamic allocation</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>The dynamic memory allocation/deallocation operation can be performed
inside a parallel region.</p>
</li>
<li>
<p>If the operation relates to a private variable, it will be local to
each task.</p>
</li>
<li>
<p>If the operation concerns a shared variable, then it is more prudent
that only one task (e.g. the master task) takes care of this operation</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_complements"><a class="anchor" href="#_complements"></a>7. Complements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The construction of a parallel region admits two other clauses:</p>
</div>
<div class="paragraph">
<p>– REDUCTION: for reduction operations with implicit synchronization
between tasks;<br>
– NUM_THREADS: it allows to specify the desired number of tasks at the
entrance of a parallel region in the same way as the OMP_SET_NUM_THREADS
subroutine would do.</p>
</div>
<div class="paragraph">
<p>From one parallel region to another, the number of concurrent tasks can be varied if desired. To do this, simply use the OMP_SET_DYNAMIC
subroutine or set the OMP_DYNAMIC environment variable to true. It is
possible to nest (nesting) parallel regions, but this only has an effect if this mode has been activated by calling the OMP_SET_NESTED subroutine or by setting the OMP_NESTED environment variable.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>*Examples*</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>#include &lt;omp.h&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>int main()
{
int row;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>#pragma omp parallel private(rank) num_threads(3)
{
rank=omp_get_thread_num();
printf("My rank in region 1: %d \n",rank);</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>#pragma omp parallel private(rank) num_threads(2)
{
rank=omp_get_thread_num();
printf(" My rank in region 2: %d \n",rank);
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>}
return 0;
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>My rank in region 1: 0
My rank in region 2: 1
My rank in region 2: 0
My rank in region 1: 2
My rank in region 2: 1
My rank in region 2: 0
My rank in region 1: 1
My rank in region 2: 0
My rank in region 2: 1</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Work sharing</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>In principle, building a parallel region and using a few OpenMP
functions alone is enough to parallelize a piece of code.</p>
</li>
<li>
<p>But, in this case, it is up to the programmer to distribute the work
as well as the data and to ensure the synchronization of the tasks.</p>
</li>
<li>
<p>Fortunately, OpenMP offers three directives (DO, SECTIONS and
WORKSHARE) which easily allow fairly fine control over the distribution
of work and data as well as synchronization within a parallel region.</p>
</li>
<li>
<p>In addition, there are other OpenMP constructs that allow the
exclusion of all but one task to execute a piece of code located in a
parallel region.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Parallel loop</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is a parallelism by distribution of the iterations of a loop.</p>
</li>
<li>
<p>The parallelized loop is the one immediately following the DO
directive.</p>
</li>
<li>
<p>"Infinite" and do while loops are not parallelizable with OpenMP.</p>
</li>
<li>
<p>The mode of distribution of iterations can be specified in the
SCHEDULE clause.</p>
</li>
<li>
<p>Choosing the distribution mode provides more control over balancing
the workload between tasks.</p>
</li>
<li>
<p>Loop indices are private integer variables.</p>
</li>
<li>
<p>By default, a global synchronization is performed at the end of the
END DO construction unless the<br>
NOWAIT clause has been specified.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>SCHEDULE clause</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>STATIC dispatching consists of dividing the iterations into packets of
a given size (except perhaps for the last one). A set of packets is then
assigned cyclically to each of the tasks, following the order of the
tasks up to the total number of packets. We could have deferred the
choice of the mode of distribution of the iterations using the
OMP_SCHEDULE environment variable. The choice of the distribution mode
of the iterations of a loop can be a major asset for balancing the
workload on a machine whose processors are not dedicated. Caution, for
vector or scalar performance reasons, avoid parallelizing loops
referring to the first dimension of a multi-dimensional array.</p>
</li>
<li>
<p>DYNAMIC: iterations are divided into packets of given size. As soon as
a task exhausts its iterations, another packet is assigned to it.</p>
</li>
<li>
<p>GUIDED: the iterations are divided into packets whose size decreases
exponentially. All the packets have a size greater than or equal to a
given value except for the last whose size may be less. As soon as a
task completes its iterations, another iteration package is assigned to
it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Case of an ordered execution</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is sometimes useful (debugging cases) to execute a loop in an
orderly fashion.</p>
</li>
<li>
<p>The order of the iterations will then be identical to that
corresponding to a sequential execution.</p>
</li>
<li>
<p>A reduction is an associative operation applied to a shared variable.</p>
</li>
<li>
<p>The operation can be:</p>
</li>
<li>
<p>arithmetic: +, --, *;<br>
logic: .AND., .OR., .EQV., .NEQV. ;<br>
an intrinsic function: MAX, MIN, IAND, IOR, IEOR.</p>
</li>
<li>
<p>Each task calculates a partial result independently of the others.
They then sync to update the final result.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Parallel sections</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A section is a portion of code executed by one and only one task.</p>
</li>
<li>
<p>Multiple portions of code can be defined by the user using the SECTION
directive within a SECTIONS construct.</p>
</li>
<li>
<p>The goal is to be able to distribute the execution of several
independent portions of code on the different tasks.</p>
</li>
<li>
<p>The NOWAIT clause is allowed at the end of the END SECTIONS construct
to remove the implicit synchronization barrier.</p>
</li>
<li>
<p>All SECTION directives must appear within the lexical scope of the
SECTIONS construct.</p>
</li>
<li>
<p>The clauses allowed in the SECTIONS directive are those we already
know:</p>
</li>
<li>
<p>PRIVATE; FIRSTPRIVATE; LASTPRIVATE; REDUCTION.</p>
</li>
<li>
<p>The PARALLEL SECTIONS directive is a merger of the PARALLEL and
SECTIONS directives with the union of their respective clauses.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Exclusive execution</strong></p>
</div>
<div class="paragraph">
<p>Sometimes you want to exclude all tasks except one to execute certain
portions of code included in a parallel region.</p>
</div>
<div class="paragraph">
<p>To do this, OpenMP offers two directives SINGLE and MASTER.</p>
</div>
<div class="paragraph">
<p>Although the aim is the same, the behavior induced by these two
constructions remains quite different.</p>
</div>
<div class="paragraph">
<p>Parallel sections</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A section is a portion of code executed by one and only one task.</p>
</li>
<li>
<p>Multiple portions of code can be defined by the user using the  directive within a construct.</p>
</li>
<li>
<p>The goal is to be able to distribute the execution of several
independent portions of code on the different tasks.</p>
</li>
<li>
<p>The NOWAIT clause is allowed at the end of the construct to remove the implicit synchronization barrier.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>SINGLE construction</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The SINGLE construction allows a portion of code to be executed by one and only one task without being able to specify which one.</p>
</li>
<li>
<p>In general, it is the task which arrives first on the SINGLE
construction but it is not specified in the standard.</p>
</li>
<li>
<p>All the tasks not executing the SINGLE region wait, at the end of the END SINGLE construction, for the termination of the one responsible for it, unless they have specified the NOWAIT clause.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>MASTER building</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The MASTER construction allows a portion of code to be executed by the master task alone.</p>
</li>
<li>
<p>This construction does not admit any clauses.</p>
</li>
<li>
<p>There is no synchronization barrier either at the beginning (MASTER)
or at the end of construction (END MASTER).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Synchronizations</strong></p>
</div>
<div class="paragraph">
<p>Synchronization becomes necessary in the following situations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>to ensure that all concurrent tasks have reached the same
level of instruction in the program (global barrier);</p>
</li>
<li>
<p>to order the execution of all the concurrent tasks when these
must execute the same portion of code affecting one or more shared
variables whose consistency (in reading or in writing) in memory must be guaranteed (mutual exclusion).</p>
</li>
<li>
<p>to synchronize at least two concurrent tasks among the set
(lock mechanism).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As we have already indicated, the absence of a NOWAIT clause means thata global synchronization barrier is implicitly applied at the end of the
\openmp construction. But it is possible to explicitly impose a global
synchronization barrier thanks to the BARRIER directive.</p>
</div>
<div class="paragraph">
<p>The mutual exclusion mechanism (one task at a time) is found, for
example, in reduction operations (REDUCTION clause) or in the ordered
execution of a loop (DO ORDERED directive). For the same purpose, this
mechanism is also implemented in the ATOMIC and CRITICAL directives.</p>
</div>
<div class="paragraph">
<p>Finer synchronizations can be achieved either by setting up lock
mechanisms (this requires calling subroutines from the OpenMP library), or by using the FLUSH directive.</p>
</div>
<div class="paragraph">
<p><strong>Barrier</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The BARRIER directive synchronizes all concurrent tasks in a parallel
region.</p>
</li>
<li>
<p>Each of the tasks waits until all the others have arrived at this
synchronization point to continue the execution of the program together.</p>
</li>
<li>
<p>Atomic Update</p>
</li>
<li>
<p>The ATOMIC directive ensures that a shared variable is read and
modified in memory by only one task at a time.</p>
</li>
<li>
<p>Its effect is local to the statement immediately following the
directive.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Critical regions</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A critical region can be seen as a generalization of the ATOMIC
directive although the underlying mechanisms are distinct.</p>
</li>
<li>
<p>The tasks execute this region in a non-deterministic order but one at a time.</p>
</li>
<li>
<p>A critical region is defined using the CRITICAL directive and applies to a portion of code terminated by END CRITICAL.</p>
</li>
<li>
<p>Its scope is dynamic.</p>
</li>
<li>
<p>For performance reasons, it is not recommended to emulate an atomic
instruction by a critical region.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>FLUSH directive</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is useful in a parallel region to refresh the value of a shared
variable in global memory.</p>
</li>
<li>
<p>It is all the more useful when the memory of a machine is hierarchical.</p>
</li>
<li>
<p>It can be used to implement a synchronization point mechanism between tasks.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Rules of good performance</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Minimize the number of parallel regions in the code.</p>
</li>
<li>
<p>Adapt the number of tasks requested to the size of the problem to be
treated in order to minimize the additional costs of task management by the system.</p>
</li>
<li>
<p>As much as possible, parallelize the outermost loop.</p>
</li>
<li>
<p>Use the SCHEDULE(RUNTIME) clause to be able to dynamically change the scheduling and the size of the iteration packets in a loop.</p>
</li>
<li>
<p>The SINGLE directive and the NOWAIT clause can make it possible to
reduce the rendering time at the cost, most often, of an explicit
synchronization.</p>
</li>
<li>
<p>The ATOMIC directive and the REDUCTION clause are more restrictive but
more powerful than the CRITICAL directive.</p>
</li>
<li>
<p>Use the IF clause to implement conditional parallelization (eg on a
vector architecture, only parallelize a loop if its length is long
enough).</p>
</li>
<li>
<p>Inter-task conflicts (of memory bank on a vector machine or of cache
faults on a scalar machine), can significantly degrade performance.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_openmp_keywords"><a class="anchor" href="#_openmp_keywords"></a>8. OpenMP keywords</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>Directive (atomic, barrier, critical, flush, ordered,…)</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An OpenMP executable directive applies to the succeeding structured
block or an OpenMP Construct. A “structured block” is a single statement
or a compound statement with a single entry at the top and a single exit
at the bottom.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>The *parallel* construction forms To team of threads and starts parallel
execution.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma comp parallel* _[clause[ [_ *,* _]clause] ...] new-line
structured-block_</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>_clause_ : *if(* _scalar- expression_ *)*</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*num_threads(* _integer-expression_ *) default(shared*  *none)
private(* _list_ *) firstprivate(* _list_ *)*</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*shared(* _list_ *) copyin(* _list_ *) reduce(* _operator_ *:* _list_
*)s*</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>loop</strong> construction specifies that the iterations of loops will be
distributed among and executed by the encountering team of threads.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma comp for* _[clause[[_ *,* _] clause] ... ] new-line for-loops_</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>_clause_ : *private(* _list_ *)*</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*firstprivate(* _list_ *) lastprivate(* _list_ *) reduce(* _operator_
*:* _list_ *) schedule(* _kind[, chunk_size]_ *) collapse(* _n_ *)*
*ordered nowait*</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>sections</strong> construct contains a set of structured blocks that are to be
distributed among and executed by the meeting team of threads.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma comp sections* _[clause[[_ *,* _] clause] ...] new line_</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*{*</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>_[_ *#pragma comp section* _new-line] structured-block_</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>_[_ *#pragma comp section* _new-line structured-block ]_</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>_clause_ : *private(* _list_ *)*</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*firstprivate(* _list_ *)
lastprivate(* _list_ *) reduce(* _operator_
*:* _list_ *) nowait*</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>single</strong> construction specifies that the associated structured block is
executed by only one of the threads in the team (not necessarily the
master thread), in the context of its implicit task.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma comp single* _[clause[[_ *,* _] clause] ...] new-line
structured-block_</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>_clause_ : *private(* _list_ *)*</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*firstprivate(* _list_ *) copyprivate(* _list_ *) nowait*</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The combined parallel worksharing constructs are a shortcut for
specifying a parallel construct containing one worksharing construct and
no other statements. Allowed clauses are the union of the clauses
allowed for the <strong>parallel</strong> and worksharing constructs.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma comp parallel for* _[clause[[_ *,* _] clause] ...] new-line
for-loop_</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma comp parallel sections* _[clause[ [_ *,* _]clause] ...]
new-line_</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*{*
_[_ *#pragma comp section* _new-line] structured-block_</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>_[_ *#pragma comp section* _new-line structured-block ]_</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>_..._
*#pragma comp task* _[clause[ [_ *,* _]clause] ...] new-line
structured-block_
_clause_ : *if(* _scalar- expression_ *)*</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>=== untied</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*default(shared  none) private(* _list_ *) firstprivate(* _list_ *)
shared(* _list_ *)*</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*Master* construction specifies To structured block that is executed by
the Master thread of the team. There is no implied barriers either on
entry to, or exit from, the master construct.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma comp Master* _new-line structured-block_</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>critical</strong> construct restricts execution of the associated structured
block to a single thread at a time.</p>
</div>
<div class="paragraph">
<p><strong>#pragma comp critical</strong> <em>[</em> <strong>(</strong> <em>name</em> <strong>)</strong> <em>] new-line structured-block</em></p>
</div>
<div class="literalblock">
<div class="content">
<pre>The *barriers* construction specifies year explicit barriers did the
point did which the construct appears.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma comp barriers* _new- line_</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>The *taskwait* construction specifies To wait we the completion of child
tasks generated since the beginning of the current task.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma comp you asked* _new line_</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>atomic</strong> construction ensures that To specific storage lease is updated
atomically, rather than exposing it to the possibility of multiple,
simultaneous writing threads.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma comp atomic* _new-line expression-stmt_</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>_stmt-expression_ : one of the following forms:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>_x binop_ *=* _expr x_ *++*</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*++* _x x_ *- -*</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*--x* ___</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>flush</strong> construction execute the OpenMP flush operation, which makes a
thread&#8217;s temporary view of memory consist with memories, and enforces an
order on the memory operations of the variables.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma comp flush* _[_ *(* _list_ *)* _] new- line_</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The <strong>ordered</strong> construct specifies a structured block in a loop region
that will be executed in the order of the loop iterations. This
sequentializes and orders the code within an ordered region while
allowing code outside the region to run in parallel.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma comp ordered* _new-line structured-block_</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="literalblock">
<div class="content">
<pre>*threadprivate* guideline specifies that variables are replicated, with
each thread having its own copy.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma comp threadprivate* _( list) new- line_</pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 27%;">
<col style="width: 73%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>Parallel Execution</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A Simple Parallel Loop</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The loop iteration variable is private by default, so it is not
necessary to specify it explicitly in a private clause</p>
</div>
<div class="literalblock">
<div class="content">
<pre>void simple(int n, float *a, float *b)
{
int i;
*#pragma omp parallel for*
for (i=1; i&lt;n; i++) /* i is private by default */
b[i] = (a[i] + a[i-1]) / 2.0;
}</pre>
</div>
</div>
<div class="paragraph">
<p>_</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The Parallel Construct</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="literalblock">
<div class="content">
<pre>The parallel construct can be used in coarse-grain parallel programs._</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>void subdomain(float *x, int istart, int ipoints)
{
int i;
for (i = 0; i &lt; ipoints; i++)
x[istart+i] = 123.456;
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>void sub(float *x, int npoints)
{
int iam, nt, ipoints, istart;
*#pragma omp parallel default(shared) private(iam,nt,ipoints,istart)*
{
iam = omp_get_thread_num();
nt = omp_get_num_threads();
ipoints = npoints / nt; /* size of partition */
istart = iam * ipoints; /* starting array index */
if (iam == nt-1) /* last thread may do more */
ipoints = npoints - istart;
subdomain(x, istart, ipoints);
}
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>main()
{
float array[10000]
sub(array, 10000)
return 0;
}</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controlling the Number of threads on Multiple Nesting Levels</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The
OMP_NUM_THREADS environment variable to control the number of threads on
multiple nesting levels</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interaction Between the num_threads Clause and omp_set_dynamic</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The call to the omp_set_dynamic routine with argument 0 in C/C++,
disables the dynamic adjustment of the number of threads in OpenMP
implementations that support it.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#include &lt;omp.h&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>int main()
{
omp_set_dynamic(0);
*#pragma omp parallel num_threads(10)*
{
/* do work here */
}
return 0;
}</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The nowait Clause</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If there are multiple independent loops within a parallel region, you can use the nowait clause to avoid the implied barrier at the end of the loop construct</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#include &lt;math.h&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>void nowait_example(int n, int m, float *a, float *b, float *y, float *z)
{
int i;
*#pragma omp parallel*
{
*#pragma omp for nowait*
for (i=1; i&lt;n; i++)
b[i] = (a[i] + a[i-1]) / 2.0;
*#pragma omp for nowait*
for (i=0; i&lt;m; i++)
y[i] = sqrt(z[i]);
}
}</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The collapse Clause</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The collapse clause is used since it is implicitly private. The collapse clause associates one or more loops with the directive on which it appears for the purpose of identifying the portion of the depth of the canonical loop nest to which to apply the semantics of the directive. The argument n speciﬁes the number of loops of the associated loop nest to which to apply those semantics. On all directives on which the collapse clause may appear, the eﬀect is as if a value of one was speciﬁed for n if the collapse clause is not speciﬁed.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>void bar(float *a, int i, int j, int k);</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>int kl, ku, ks, jl, ju, js, il, iu,is;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>void sub(float *a)
{
int i, j, k;
*#pragma omp for collapse(2) private(i, k, j)*
for (k=kl; k&lt;=ku; k+=ks)
for (j=jl; j&lt;=ju; j+=js)
for (i=il; i&lt;=iu; i+=is)
bar(a,i,j,k);
}</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Linear Clause in Loop Constructs</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The linear clause in a loop construct to allow the proper
parallelization of a loop that contains an induction variable (<em>j</em>). At
the end of the execution of the loop construct, the original variable
<em>j</em> is updated with the value <em>N/2</em> from the last iteration of the loop.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#include &lt;stdio.h&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>#define N 100</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>int main(void)
{
float a[N], b[N/2];
int i, j;
for(i = 0;i&lt;N;i++)
a[i] = i+1;
j=0
*#pragma omp parallel*
*#pragma omp for linear(j:1)*
for(i=0;i&lt;N;i+=2){
b[j]= a[i] * 2.0f;
j++;
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>printf"%d %f %f\n", j, b[0], b[j-1] );
/* print out: 50 2.0 198.0 */
return 0;
}</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The firstprivate Clause and the sections Construct</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The firstprivate clause is used to initialize the private copy of
section_count of each thread. The problem is that the section constructs modify section_count, which breaks the independence of the section constructs. When different threads execute each section, both sections will print the value 1. When the same thread executes the two sections, one section will print the value 1 and the other will print the value 2.
Since the order of execution of the two sections in this case is
unspecified, it is unspecified which section prints which value.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#include &lt;stdio.h&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>#define NT 4</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>int main( ) {</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>int section_count = 0;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*omp_set_dynamic(0);*
*omp_set_num_threads(NT);*
*#pragma omp parallel*
*#pragma omp sections firstprivate( section_count )*
{</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma omp section*
{
section_count++;
/* may print the number one or two */
printf( "section_count %d\n", section_count );</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma omp section*
{
section_count++;
/* may print the number one or two */
printf( "section_count %d\n", section_count );
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>return 0;
}</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The single Construct</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Only one thread prints each of the progress messages. All other threads
will skip the single region and stop at the barrier at the end of the
single construct until all threads in the team have reached the barrier.
If other threads can proceed without waiting for the thread executing
the single region, a nowait clause can be specified, as is done in the
third single construct in this example. The user must not make any
assumptions as to which thread will execute a single region.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#include &lt;stdio.h&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>void work1() {}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>void work2() {}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>void single_example()</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma omp parallel*
{
*#pragma omp single*
printf("Beginning work1.\n");
work1();
*#pragma omp single*
printf("Finishing work1.\n");
*#pragma omp single nowait*
printf("Finished work1 and beginning work2.\n");
work2();
}
}</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The master Construct</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="literalblock">
<div class="content">
<pre>#include &lt;stdio.h&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>extern float average(float,float,float);
void master_example( float* x, float* xold, int n, float tol )
{
int c, i, toobig;
float error, y;
c = 0;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>#*pragma omp parallel*
{
do {
*#pragma omp for private(i)*
for( i = 1; i &lt; n-1; ++i ){
xold[i] = x[i];
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma omp single*
{
toobig = 0;
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma omp for private(i,y,error) reduction(+:toobig)*
for(i=1; i&lt;n-1;++i){
y = x[i];
x[i] = average( xold[i-1], x[i], xold[i+1] );
error = y - x[i];
if( error &gt; tol or error &lt; -tol ) ++toobig;
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma omp master*
{
++c;
printf( "iteration %d, toobig=%d\n", c, toobig );
}
} while( toobig &gt; 0 );
}
}</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parrallel Random Access Iterator Loop</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="literalblock">
<div class="content">
<pre>#include &lt;vector&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>void iterator_example()</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>{
std::vector&lt;int&gt; vec(23);
std::vector&lt;int&gt;::iterator it;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>*#pragma omp parallel for default(none) shared(vec)*
for (it = vec.begin(); it &lt; vec.end(); it++)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>{
// do work with *it //
}
}</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The omp_set_dynamic and omp_set_num_threads Routines</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Some programs rely on a fixed, prespecified number of threads to execute
correctly. Because the default setting for the dynamic adjustment of the
number of threads is implementation defined, such programs can choose to
turn off the dynamic threads capability and set the number of threads
explicitly to ensure portability.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#include &lt;omp.h&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>#include &lt;stdlib.h&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>void do_by_16(float *x, int iam, int ipoints) {}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>void dynthreads(float *x, int npoints)
{
int iam, ipoints;
*omp_set_dynamic(0);*
*omp_set_num_threads(16);*
*#pragma omp parallel shared(x, npoints) private(iam, ipoints)*
{
if (omp_get_num_threads() != 16) abort();
iam = omp_get_thread_num();
ipoints = npoints/16;
do_by_16(x, iam, ipoints);
}
}</pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 26%;">
<col style="width: 74%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>Clauses: Data Sharing attribute</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Data sharing attribute clauses apply only to variables whose names are
visible in the construct on which the clause appears. Not all of the
clauses are valid on all directives. The set of clauses that is valid we
To particular guideline is described with the directive. Most of the
clauses accept a comma-separated list of list items. All list items
appearing in a clause must be visible.</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>default(shared none);</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Controls the default data sharing attributes of variables that are referenced in a <strong>parallel</strong> or <strong>task</strong> construct.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>shared(</strong> <em>list</em> <strong>);</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Declared one gold more list items to be shared by tasks generated by a <strong>parallel</strong> or <strong>task</strong> construct.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>private(</strong> <em>list</em> <strong>);</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Declared one or more list items to be private to a task.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>firstprivate(</strong> <em>list</em> <strong>);</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Declared one gold more list items to be private to To task, and initialize each of them with the value that the corresponding original item has when the construct is encountered.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>lastprivate(</strong> <em>list</em> <strong>);</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Declares one or more list items to be private to an implicit task, and causes the corresponding original item to be updated after the end of the region.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>reduce(</strong> <em>operator</em> <strong>:</strong> <em>list</em> <strong>);</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Declares accumulation into the list items using the indicated associative operator. Accumulation occurs into To private copy for each list item which is then combined with the original item.</p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 24%;">
<col style="width: 76%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>Clauses: Data copying</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Thesis clauses support the copying of data values from private gold thread- private variables on one implicit task or thread to the corresponding variables on other implicit tasks or threads in the team.</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>copyin(</strong> <em>list</em> <strong>);</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Copies the value of the master thread&#8217;s <em>threadprivate</em> variable to the <em>threadprivate</em> variable of each other member of the team executing the <strong>parallel</strong> region.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>copyprivate(</strong> <em>list</em> <strong>);</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Broadcasts a value from the data environment of one implicit task to the data environments of the other implied tasks belonging to the <strong>parallel</strong> region.</p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 39%;">
<col style="width: 61%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>Execution Environment Routines Function</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Execution environment routines affect and monitor threads, processors,
and the parallel environment. Lock routines support synchronization with
OpenMP locks. Timing routines support a portable wall clock timer.
prototypes for the runtime library routines are defined in the queue
“omp.h”.</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>void omp_set_num_threads(int* <em>num_threads</em> *);</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Affects the number of threads used for subsequent <strong>parallel</strong> regions that do not specify To <strong>num_threads</strong> clause.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>int omp_get_num_threads(void);</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the nusmber of threads in the current team.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>int omp_get_max_threads(void);</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns maximum number of threads that could be used to form To new team using a “parallel” construct without has “num_threads” clause.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>int omp_get_thread_num(void);</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns tea ID of the meeting thread where ID rows from zero to the size of the team minus 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>int omp_get_num_procs(void);</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the number of processors available to the program.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>int omp_in_parallel(void);</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <em>true</em> if the call to the routine is enclosed by an active <strong>parallel</strong> region; otherwise, it returns <em>false</em> .</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>void omp_set_dynamic(int* <em>dynamic_threads</em> *);</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables gold disables dynamic adjustments of the number of threads available.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>int omp_get_dynamic(void);</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the value of the <em>dyn-var</em> internal control variable (ICV), determining whether dynamic adjustments of the number of threads is enabled or disabled.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>void omp_set_nested(int <em>nested</em> );</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables gold disables nested parallelism, by setting the _nest-var_ICV.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>int omp_get_nested(void);</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the value of the <em>nest-var</em> LCI, which determined if nestedparallelism is enabled or disabled.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>void omp_set_schedule(omp_sched_t* <em>kind</em> <strong>, int</strong> <em>modify</em> *);</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Affects the schedule that is applied when <strong>run-time</strong> is used as schedule kind, by setting the value of the <em>run-sched-var</em> ICV.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>void omp_get_schedule (omp_sched_t *kind, int *edit)s;</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the schedule applied when <strong>run-time</strong> schedule is used.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>int omp_get_thread_limit(void)*</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the maximum number of OpenMP threads available to the program.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>int omp_get_thread_limit(void)*</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the maximum number of OpenMP threads available to the program.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>void omp_set_max_active_levels(int* <em>max_levels</em> <strong>);</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Limits the number of nested active <strong>parallel</strong> regions, by setting the <em>max-active-levels-var</em> ICV.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>int omp_get_max_active_levels(void);</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns tea value of tea <em>max-activelevels-var LCI</em> , which determines
the maximum number of nested active <strong>parallel</strong> regions.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>int omp_get_level(void);</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns tea number of nested <strong>parallel</strong> regions enclosing tea task that contains the call.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>int omp_get_ancestor_thread_num(int <em>level</em> );</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns, for To given nested level of tea current thread, tea thread number of the ancestor or the current thread.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>int omp_get_team_size(int <em>level</em> );</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns, for To given nested level of tea current thread, tea size of the thread team to which the ancestor or the current thread belongs.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>int omp_get_active_level(void);</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns tea number of nested, active <strong>parallel</strong> regions enclosing the task that contains the call.</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 41%;">
<col style="width: 59%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>Lock Routines</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>void omp_init_lock(omp_lock_t * <em>lock</em> );</p>
</div>
<div class="paragraph">
<p><strong>void omp_init_nest_lock(omp_nest_lock_t *</strong> <em>lock</em> <strong>);</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Routines initialize year OpenMP lock.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>void omp_destroy_lock(omp_lock_t * <em>lock</em> );</p>
</div>
<div class="paragraph">
<p><strong>void omp_destroy_nest_lock(omp_nest_lock_t *</strong> <em>lock</em> <strong>);</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Routines ensure that the OpenMP lock is uninitialized.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>void omp_set_lock(omp_lock_t * <em>lock</em> );</p>
</div>
<div class="paragraph">
<p><strong>void omp_set_nest_lock(omp_nest_lock_t *</strong> <em>lock</em> <strong>);</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Routines provide To means of setting year OpenMP lock.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>void omp_unset_lock(omp_lock_t * <em>lock</em> );</p>
</div>
<div class="paragraph">
<p><strong>void omp_unset_nest_lock(omp_nest_lock_t *</strong> <em>lock</em> <strong>);</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Routines provide To means of setting year OpenMP lock.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>int omp_test_lock(omp_lock_t * <em>lock</em> );</p>
</div>
<div class="paragraph">
<p><strong>int omp_test_nest_lock(omp_nest_lock_t *</strong> <em>lock</em> <strong>);</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Routines attempt to set year OpenMP lock aim do not suspend execution of the task executing the routine.</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 41%;">
<col style="width: 59%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>Timing Routines</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>double omp_get_wtime(void);</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns elapsed wall clock time in seconds.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>double omp_get_wtick(void);</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the precision of the timer used by <strong>omp_get_wtime</strong> .</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 35%;">
<col style="width: 65%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>Environment Variables</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Environment variable names are upper case, and the values assigned to them are box insensitive and May have leading and trailing white space.</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>OMP_SCHEDULE* <em>type</em> <strong>[,</strong> <em>chunk</em> *]</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the <em>run-sched-var</em> ICV for the runtime schedule type and chunk size. Valid OpenMP schedule types are <strong>static</strong> <em>,</em> <strong>dynamic</strong> <em>,</em> <strong>guided</strong> , or <strong>auto</strong> . <em>Chunk</em> is a positive integer.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>OMP_NUM_THREADS <em>number</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the <em>nthreads-var</em> LCI for tea number of threads to worn for <strong>parallel</strong> regions.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>OMP_DYNAMIC</strong> <em>dynamic</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the <em>dyn-var</em> ICV <em>for</em> the dynamic adjustment of threads to use for <strong>parallel</strong> regions. Valid values for <em>dynamic</em> are <strong>true</strong> gold <strong>false</strong> .</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>OMP_NESTED</strong> <em>nested</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the <em>nest-var</em> LCI to enable gold to disable nested parallelism. Valid values for <em>nested</em> are true or false.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>OMP_STACKSIZE</strong> <em>size</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the <em>stacksize-var</em> ICV that specifies the size of the stack for threads created by the OpenMP implementation. Valid values for <em>size</em> (a positive integer) are <em>size</em> , <em>size</em> <strong>B</strong> , <em>size</em> <strong>K</strong> , <em>size</em> <strong>M</strong> ,<em>size</em> <strong>G.</strong> _ Yew units <strong>B</strong> , <strong>K</strong> , <strong>M</strong> or <strong>G</strong> are not specified, size is measured in kilobytes ( <strong>K</strong> ).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>OMP_WAIT_POLICY</strong> <em>policy</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the <em>wait-policy-var</em> ICV that controls the desired behavior of waiting threads. Valid values for <em>policy</em> are <strong>active</strong> (waiting threads consume processor cycles while waiting) and <strong>passive</strong> .</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>OMP_MAX_ACTIVE_LEVELS</strong> <em>levels</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets tea <em>max-active-levels-var</em> LCI that controls the maximum number of nested active <strong>parallel</strong> regions.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>OMP_THREAD_LIMIT</strong> <em>limit</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets tea <em>thread-limit-var</em> LCI that controls the maximum number of threads participating in the OpenMP program.</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 35%;">
<col style="width: 65%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>Operators legally allowed in at discount</strong></th>
<th class="tableblock halign-left valign-top"></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>Operator</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>Initialization value</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>+</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>*</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>-</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>&amp;</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>~0</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>^</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>&amp;&amp;</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 22%;">
<col style="width: 78%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>Schedule types for the loop construct</strong></th>
<th class="tableblock halign-left valign-top"></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>static</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Iterations are divided into chunks of size <em>chunk_size</em> , and the chunks are assigned to the threads in the team in a round-robin fashion in the order of the thread number.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>dynamic</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Each thread execute To chunk of iterations, then requests another chunk, until no chunks remain to be distributed.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>guided</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Each thread execute To chunk of iterations, then requests another chunk, until no chunks remain to be assigned. The chunk sizes start large and shrink to the indicated <em>chunk_size</em> as chunks are scheduled.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>car</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The decision regarding scheduling is delegated to the compiler and/or runtime system.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>run-time</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The schedule and chunk size are taken from the run-sched-var ICV.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer" style="border-top: 2px solid #e9e9e9; background-color: #fafafa; padding-bottom: 2em; padding-top: 2em;">
    <div class="container" style="display: flex; flex-direction: column; align-items: center; gap: 0.5em;">
        <div>
            <a href="https://www.cemosis.fr">
                <img src="../_/img/cemosis-logo.svg" alt="Cemosis logo" height="50">
            </a>
        </div>
        <span style="font-size: 0.8rem; color: #9e9e9e">© 2023 <a href="https://www.cemosis.fr" style="text-decoration: underline;">Cemosis</a>, Université de Strasbourg</span>
    </div>
</footer>
<script id="site-script" src="../_/js/site.js" data-ui-root-path="../_"></script>


<script async src="../_/js/vendor/fontawesome-icon-defs.js"></script>
<script async src="../_/js/vendor/fontawesome.js"></script>
<script async src="../_/js/vendor/highlight.js"></script>


<script type="text/javascript">
function toggleFullScreen() {
   var doc = window.document;
   var docEl = doc.documentElement;

   var requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
   var cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

   if(!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
       requestFullScreen.call(docEl);
   }
   else {
       cancelFullScreen.call(doc);
   }
}
</script>
  </body>
</html>
